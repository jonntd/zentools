requires "closestPointOnMesh";
requires "decomposeMatrix";

proc string[] rigZenTangentSpaceMuscleCluster(string $sel,int $createJiggle, int $reverseU)
{
	string	$surfaceSh=zenReturnFirstStringItem(stringArrayCatenate(`ls -type shape $sel`,`listRelatives -s -ni $sel`));
	string	$surfaceTr=zenReturnFirstStringItem(`listRelatives -p $surfaceSh`);
	string	$inSurface=zenReturnFirstStringItem(`listConnections -plugs 1 ($surfaceSh+".create")`);
	string	$computeSurface=$surfaceSh;

	int	$local=getAttr($surfaceTr+".inheritsTransform");

	//check for history

		if(`objExists $inSurface`)
		{
			$computeSurface=`createNode -p $surfaceTr nurbsSurface`;
			setAttr ($computeSurface+".caching") true;
			connectAttr $inSurface ($computeSurface+".create");
		}

		setAttr ($computeSurface+".caching") true;

	string	$clusterSpace;
	string	$clusterAutoTr;
	string	$clusterTr;
	string	$clusterHandleShape;
	string	$makeNurbSphereNode;
	string	$pointOnSurfaceInfoNode;
	string	$decomposeMatrixNode;
	string	$fourByFourMatrixNode;
	string	$scaleCompensateDecomposeMatrix;
	string	$parentTr;
	string	$clusterSpaceGroup;

		$parentTr=zenReturnFirstStringItem(`listRelatives -p $surfaceTr`);

	string	$muscleCtrlsGroup="muscleCtrls";

		if(!objExists("muscleCtrls") || !size(`ls -tr "muscleCtrls"`))
			$muscleCtrlsGroup=`createNode -name "muscleCtrls" "transform"`;

	string	$uniqueName=`zenUniqueName "muscleCtrl"`;

		$clusterSpaceGroup=`createNode -p $muscleCtrlsGroup -n $uniqueName transform`;

		$clusterSpace=`createNode -p $clusterSpaceGroup -n "tangentSpace#" transform`;

			setAttr ($clusterSpace+".inheritsTransform") 0;

			if($reverseU) setAttr ($clusterSpace+".sz") -1;
			setAttr -lock true ($clusterSpace+".sx");
			setAttr -lock true ($clusterSpace+".sy");
			setAttr -lock true ($clusterSpace+".sz");

		if(`objExists $parentTr`)
		{
			$scaleCompensateDecomposeMatrix=`createNode decomposeMatrix`;
			setAttr ($scaleCompensateDecomposeMatrix+".caching") true;
			//if($local)
				//connectAttr ($parentTr+".matrix") ($scaleCompensateDecomposeMatrix+".inputMatrix");
			//else
				connectAttr ($parentTr+".worldMatrix[0]") ($scaleCompensateDecomposeMatrix+".inputMatrix");
			setAttr ($parentTr+".caching") true;
		}

		$clusterAutoTr=`createNode -p $clusterSpace -n "tangentSpaceAutoFlex#" transform`;
			setAttr ($clusterAutoTr+".caching") true;

		$clusterTr=`createNode -p $clusterAutoTr -n (zenUniqueName("muscleCtrl")) transform`;
			setAttr ($clusterTr+".caching") true;

			addAttr -ln "zenMuscle" -at message $clusterTr;
			addAttr -ln "zenMuscleCtrlGroup" -at message $clusterTr;
			addAttr -ln "zenOpposite" -at message $clusterTr;
			addAttr -m -ln "zenAutoFlex" -sn "zaf" -at compound -nc 15 $clusterTr;
				addAttr -p "zenAutoFlex" -k 1 -ln "poseDepth" -sn "zpd" -at double -min 0.0 -max 1.0 -dv .5 $clusterTr;
				addAttr -p "zenAutoFlex" -k 1 -ln "autoFlexBias" -sn "zafb" -at double -min 0.0 -max 1.0 -dv 0 $clusterTr;
				addAttr -p "zenAutoFlex" -k 1 -ln "autoUPos" -sn "zaup" -at double -min 0.0 -max 1.0 -dv .5 $clusterTr;
				addAttr -p "zenAutoFlex" -k 1 -ln "autoFallOff" -sn "zafo" -at double -min 0.0 -max 1.0 -dv .8 $clusterTr;
				addAttr -p "zenAutoFlex" -k 1 -ln "autoTransX" -sn "zatx" -at double -dv 0 $clusterTr;
				addAttr -p "zenAutoFlex" -k 1 -ln "autoTransY" -sn "zaty" -at double -dv 0 $clusterTr;
				addAttr -p "zenAutoFlex" -k 1 -ln "autoTransZ" -sn "zatz" -at double -dv 0 $clusterTr;
				addAttr -p "zenAutoFlex" -k 1 -ln "autoRotX" -sn "zarx" -at double -dv 0 $clusterTr;
				addAttr -p "zenAutoFlex" -k 1 -ln "autoRotY" -sn "zary" -at double -dv 0 $clusterTr;
				addAttr -p "zenAutoFlex" -k 1 -ln "autoRotZ" -sn "zarz" -at double -dv 0 $clusterTr;
				addAttr -p "zenAutoFlex" -k 1 -ln "autoScaleX" -sn "zasx" -at double -dv 1 $clusterTr;
				addAttr -p "zenAutoFlex" -k 1 -ln "autoScaleY" -sn "zasy" -at double -dv 1 $clusterTr;
				addAttr -p "zenAutoFlex" -k 1 -ln "autoScaleZ" -sn "zasz" -at double -dv 1 $clusterTr;
				addAttr -m -p "zenAutoFlex" -ln "zenPoseAttr" -sn "zpa" -at message $clusterTr;
				addAttr -m -p "zenAutoFlex" -ln "zenAttrVal" -sn "zav" -at double $clusterTr;

			connectAttr ($surfaceSh+".message") ($clusterTr+".zenMuscle");
			connectAttr ($clusterSpaceGroup+".message") ($clusterTr+".zenMuscleCtrlGroup");

		$clusterHandleShape=`createNode -p $clusterTr -n (zenUniqueName($clusterTr+"Shape")) nurbsSurface`;

		//weight control attributes

		addAttr -k 1 -ln "uPos" -at double -min .01 -max .99 -hsn true -hsx true -smn .1 -smx .9 -dv .5 $clusterTr;
		addAttr -k 1 -ln "fallOff" -at double -min 0 -max 1 -dv .8 $clusterTr;
		addAttr -k 1 -ln "centerWidth" -at double -min 0 -max 1 -dv 0 $clusterTr;
		addAttr -k 1 -ln "tangentSpace" -at double -min 0 -max 1 -dv 0 $clusterTr;

	//jiggle attributes

		if($createJiggle)
		{
			addAttr -k 1 -ln "jiggle" -sn "j" -at "enum" -en "enable:disable:enableOnlyAfterObjectStops:" -dv 1 $clusterTr;
			addAttr -k 1 -ln "jEnvelope" -sn "jE" -at double -min 0 -max 1  -dv 1 $clusterTr;
			addAttr -k 1 -ln "jDamping" -sn "jD" -at double -min 0 -max 1 -dv .5 $clusterTr;
			addAttr -k 1 -ln "jStiffness" -sn "jS" -at double -min 0 -max 1 -dv .5 $clusterTr;
			addAttr -k 1 -ln "jWeight" -sn "jW" -at double -min 0 -dv 1 $clusterTr;
			addAttr -k 1 -ln "jForceNormal" -sn "jFN" -at double -min 0 -max 1 -dv 1 $clusterTr;
			addAttr -k 1 -ln "jForceTangent" -sn "jFT" -at double -min 0 -max 1 -dv 1 $clusterTr;
			addAttr -k 1 -ln "jDirBias" -sn "jDB" -at double -min 0 -max 1 -dv .5 $clusterTr;
			addAttr -k 1 -ln "jIgnoreTr" -sn "jIT" -at bool -dv 0 $clusterTr;
			addAttr -k 1 -ln "jMotionMult" -sn "jMM" -at double -min 0 -dv 1 $clusterTr;
		}

	//display attributes

		addAttr -ln "handleOffsetX" -at double -dv 4 $clusterTr;
		setAttr -k false -cb true ($clusterTr+".handleOffsetX");

		addAttr -ln "handleOffsetY" -at double -dv 0 $clusterTr;
		setAttr -k false -cb true ($clusterTr+".handleOffsetY");

		addAttr -ln "handleOffsetZ" -at double -dv 0 $clusterTr;
		setAttr -k false -cb true ($clusterTr+".handleOffsetZ");

		addAttr -ln "handleRadius" -at double -dv 1 $clusterTr;
		setAttr -k false -cb true ($clusterTr+".handleRadius");

		$makeNurbSphereNode=`createNode makeNurbSphere`;

			setAttr ($clusterHandleShape+".curvePrecisionShaded") 4;

	string	$handleOffsetMultiplier=`createNode multiplyDivide`;

		setAttr ($handleOffsetMultiplier+".i1") 1 1 1;

	string	$handleRadiusMultiplier=`createNode multDoubleLinear`;

		connectAttr ($clusterTr+".handleRadius") ($handleRadiusMultiplier+".i1");

		connectAttr ($clusterTr+".handleOffsetX") ($handleOffsetMultiplier+".i2x");
		connectAttr ($clusterTr+".handleOffsetY") ($handleOffsetMultiplier+".i2y");
		connectAttr ($clusterTr+".handleOffsetY") ($handleOffsetMultiplier+".i2z");


		connectAttr ($handleOffsetMultiplier+".ox") ($makeNurbSphereNode+".pivotX");
		connectAttr ($handleOffsetMultiplier+".oy") ($makeNurbSphereNode+".pivotY");
		connectAttr ($handleOffsetMultiplier+".oz") ($makeNurbSphereNode+".pivotZ");

		connectAttr ($makeNurbSphereNode+".outputSurface") ($clusterHandleShape+".create");

		if(`objExists $parentTr`)
		{
			connectAttr ($scaleCompensateDecomposeMatrix+".outputScaleY")  ($handleRadiusMultiplier+".i2");
			connectAttr ($handleRadiusMultiplier+".o") ($makeNurbSphereNode+".radius");

			connectAttr ($scaleCompensateDecomposeMatrix+".outputScaleY")  ($handleOffsetMultiplier+".i1x");
			connectAttr ($scaleCompensateDecomposeMatrix+".outputScaleY")  ($handleOffsetMultiplier+".i1y");
			connectAttr ($scaleCompensateDecomposeMatrix+".outputScaleY")  ($handleOffsetMultiplier+".i1z");
		}

	string	$multNormal;

		$pointOnSurfaceInfoNode=`createNode pointOnSurfaceInfo`;
			setAttr ($pointOnSurfaceInfoNode+".caching") true;

			connectAttr ($computeSurface+".worldSpace[0]") ($pointOnSurfaceInfoNode+".inputSurface");
			connectAttr ($clusterTr+".uPos") ($pointOnSurfaceInfoNode+".parameterU");

			setAttr ($pointOnSurfaceInfoNode+".parameterV") .5;

		$decomposeMatrixNode=`createNode decomposeMatrix`;
			setAttr ($decomposeMatrixNode+".caching") true;
		$fourByFourMatrixNode=`createNode fourByFourMatrix`;
			setAttr ($fourByFourMatrixNode+".caching") true;

			connectAttr ($pointOnSurfaceInfoNode+".nnx") ($fourByFourMatrixNode+".in00");
			connectAttr ($pointOnSurfaceInfoNode+".nny") ($fourByFourMatrixNode+".in01");
			connectAttr ($pointOnSurfaceInfoNode+".nnz") ($fourByFourMatrixNode+".in02");

			connectAttr ($pointOnSurfaceInfoNode+".nux") ($fourByFourMatrixNode+".in10");
			connectAttr ($pointOnSurfaceInfoNode+".nuy") ($fourByFourMatrixNode+".in11");
			connectAttr ($pointOnSurfaceInfoNode+".nuz") ($fourByFourMatrixNode+".in12");

			connectAttr ($pointOnSurfaceInfoNode+".nvx") ($fourByFourMatrixNode+".in20");
			connectAttr ($pointOnSurfaceInfoNode+".nvy") ($fourByFourMatrixNode+".in21");
			connectAttr ($pointOnSurfaceInfoNode+".nvz") ($fourByFourMatrixNode+".in22");

			connectAttr ($pointOnSurfaceInfoNode+".px")  ($fourByFourMatrixNode+".in30");
			connectAttr ($pointOnSurfaceInfoNode+".py")  ($fourByFourMatrixNode+".in31");
			connectAttr ($pointOnSurfaceInfoNode+".pz")  ($fourByFourMatrixNode+".in32");

			connectAttr ($fourByFourMatrixNode+".output") ($decomposeMatrixNode+".inputMatrix");

			connectAttr ($decomposeMatrixNode+".outputTranslate") ($clusterSpace+".t");
			connectAttr ($decomposeMatrixNode+".outputRotate") ($clusterSpace+".r");

	//create clusters

	string	$clusterNodes[];
	string	$handleShape;
	string	$multMatrixNode;
	string	$multMatrixNode2;
	string	$clusterPointOnSurfaceInfo;
	string	$clusterFourByFourMatrix;
	string	$clusterNodeSpace;
	string	$decomposeClusterNodeSpace;
	string	$blendRotMatrix;
	string	$blendTrMatrix;
	string	$blendRotPreBindMatrix;
	string	$blendTrPreBindMatrix;
	string	$blendClusterSpaceAddMatrix;

	string	$reverseMatrixWeighting=`createNode reverse`;
		connectAttr ($clusterTr+".tangentSpace") ($reverseMatrixWeighting+".ix");

	float	$uCount=size(ls("-fl",($surfaceSh+".cv[*][0]")));
	float	$vCount=size(ls("-fl",($surfaceSh+".cv[0][*]")));


	int	$startNum=`getAttr ($computeSurface+".degreeU")`;
	int	$weightID=$vCount*$startNum;

		for($i=$startNum;$i<($uCount-$startNum);$i++)
		{
			$clusterFourByFourMatrix=`createNode fourByFourMatrix`;
				setAttr ($clusterFourByFourMatrix+".caching") true;

			$clusterPointOnSurfaceInfo=`createNode pointOnSurfaceInfo`;
				setAttr ($clusterPointOnSurfaceInfo+".caching") true;

				setAttr ($clusterPointOnSurfaceInfo+".parameterU") ((float($i))/($uCount-1));
				setAttr ($clusterPointOnSurfaceInfo+".parameterV") .5;

				connectAttr ($computeSurface+".worldSpace[0]") ($clusterPointOnSurfaceInfo+".inputSurface");

				connectAttr ($clusterPointOnSurfaceInfo+".nnx") ($clusterFourByFourMatrix+".in00");
				connectAttr ($clusterPointOnSurfaceInfo+".nny") ($clusterFourByFourMatrix+".in01");
				connectAttr ($clusterPointOnSurfaceInfo+".nnz") ($clusterFourByFourMatrix+".in02");

				connectAttr ($clusterPointOnSurfaceInfo+".nux") ($clusterFourByFourMatrix+".in10");
				connectAttr ($clusterPointOnSurfaceInfo+".nuy") ($clusterFourByFourMatrix+".in11");
				connectAttr ($clusterPointOnSurfaceInfo+".nuz") ($clusterFourByFourMatrix+".in12");

				connectAttr ($clusterPointOnSurfaceInfo+".nvx") ($clusterFourByFourMatrix+".in20");
				connectAttr ($clusterPointOnSurfaceInfo+".nvy") ($clusterFourByFourMatrix+".in21");
				connectAttr ($clusterPointOnSurfaceInfo+".nvz") ($clusterFourByFourMatrix+".in22");

				connectAttr ($clusterPointOnSurfaceInfo+".px")  ($clusterFourByFourMatrix+".in30");
				connectAttr ($clusterPointOnSurfaceInfo+".py")  ($clusterFourByFourMatrix+".in31");
				connectAttr ($clusterPointOnSurfaceInfo+".pz")  ($clusterFourByFourMatrix+".in32");

			$multMatrixNode=`createNode multMatrix`;
				setAttr ($multMatrixNode+".caching") true;

				connectAttr -f ($clusterTr+".matrix") ($multMatrixNode+".i[0]");
				connectAttr -f ($clusterAutoTr+".matrix") ($multMatrixNode+".i[1]");

			$clusterNodeSpace=`createNode -n "clusterSpace#" -p $clusterSpaceGroup transform`;
				setAttr ($clusterNodeSpace+".caching") true;

				setAttr ($clusterNodeSpace+".inheritsTransform") 0;

				if($reverseU) setAttr ($clusterNodeSpace+".sz") -1;
				setAttr -lock true ($clusterNodeSpace+".sx");
				setAttr -lock true ($clusterNodeSpace+".sy");
				setAttr -lock true ($clusterNodeSpace+".sz");

			$decomposeClusterNodeSpace=`createNode decomposeMatrix`;
				setAttr ($decomposeClusterNodeSpace+".caching") true;

				connectAttr -f ($clusterFourByFourMatrix+".o") ($decomposeClusterNodeSpace+".imat");
				connectAttr -f ($decomposeClusterNodeSpace+".outputRotate") ($clusterNodeSpace+".r");
				connectAttr -f ($decomposeClusterNodeSpace+".outputTranslate") ($clusterNodeSpace+".t");

			//create tangent space blender

			$blendTrMatrix=`createNode blendColors`;

				connectAttr -f ($decomposeClusterNodeSpace+".outputTranslate") ($blendTrMatrix+".c1");
				connectAttr -f ($decomposeMatrixNode+".outputTranslate") ($blendTrMatrix+".c2");
				connectAttr -f ($clusterTr+".tangentSpace") ($blendTrMatrix+".b");

			$blendRotMatrix=`createNode blendColors`;

				connectAttr -f ($decomposeClusterNodeSpace+".outputRotate") ($blendRotMatrix+".c1");
				connectAttr -f ($decomposeMatrixNode+".outputRotate") ($blendRotMatrix+".c2");
				connectAttr -f ($clusterTr+".tangentSpace") ($blendRotMatrix+".b");

			$clusterNodes=cluster($surfaceSh+".cv["+(string($i))+"][*]");

				connectAttr -f ($multMatrixNode+".o") ($clusterNodes[0]+".matrix");
				connectAttr -f ($clusterNodeSpace+".worldInverseMatrix") ($clusterNodes[0]+".bindPreMatrix");
				connectAttr -f ($clusterNodeSpace+".worldMatrix[0]")  ($multMatrixNode+".i[2]");

				connectAttr -f ($blendRotMatrix+".op") ($clusterNodeSpace+".r");
				connectAttr -f ($blendTrMatrix+".op") ($clusterNodeSpace+".t");

			$handleShape=zenReturnFirstStringItem(`listRelatives -s -ni $clusterNodes[1]`);

			disconnectAttr ($handleShape+".clusterTransforms[0]") (zenReturnFirstStringItem(listConnections("-plugs",true,$handleShape+".clusterTransforms[0]")));

			delete $clusterNodes[1];
		}

	//create jiggle

	string	$jiggleNode;
	string	$jiggleCache;

		if($createJiggle)
		{
			$jiggleNode=zenReturnFirstStringItem(`deformer -n "jiggle#" -type jiggle $surfaceSh`);

				connectAttr ($clusterTr+".j") ($jiggleNode+".enable");
				connectAttr ($clusterTr+".jE") ($jiggleNode+".envelope");
				connectAttr ($clusterTr+".jD") ($jiggleNode+".dp");
				connectAttr ($clusterTr+".jS") ($jiggleNode+".sf");
				connectAttr ($clusterTr+".jW") ($jiggleNode+".jw");
				connectAttr ($clusterTr+".jFN") ($jiggleNode+".fan");
				connectAttr ($clusterTr+".jFT") ($jiggleNode+".fot");
				connectAttr ($clusterTr+".jDB") ($jiggleNode+".bias");
				connectAttr ($clusterTr+".jIT") ($jiggleNode+".it");
				connectAttr ($clusterTr+".jMM") ($jiggleNode+".motionMultiplier");

			//create jiggle cache

			$jiggleCache=`createNode -n ($jiggleNode+"Cache") diskCache`;

				setAttr -type "string" ($jiggleCache+".cacheName") $jiggleCache;
				connectAttr ($jiggleCache+".diskCache") ($jiggleNode+".diskCache");
				catch(connectAttr(((zenReturnFirstStringItem(`ls -type time`))+".outTime"),($jiggleNode+".currentTime")));
		}

	//create blendShape for weighting

	string	$blendShapeNode=zenReturnFirstStringItem(`blendShape -o local -w 0 1 $computeSurface $surfaceSh`);
			setAttr ($blendShapeNode+".caching") true;

	//create falloff ramp

	string	$controlRamp=`createNode ramp`;

			setAttr ($controlRamp+".colorEntryList[0].position") .1;
			setAttr ($controlRamp+".colorEntryList[1].position") .475;
			setAttr ($controlRamp+".colorEntryList[2].position") .525;
			setAttr ($controlRamp+".colorEntryList[3].position") .9;

			setAttr ($controlRamp+".colorEntryList[0].color") -type double3 1 1 1;
			setAttr ($controlRamp+".colorEntryList[1].color") -type double3 .2 .2 .2;
			setAttr ($controlRamp+".colorEntryList[2].color") -type double3 .2 .2 .2;
			setAttr ($controlRamp+".colorEntryList[3].color") -type double3 1 1 1;

			//interpolation & type

			setAttr ($controlRamp+".type") 1;
			setAttr ($controlRamp+".interpolation ") 6;

	string	$weightRamps[];

		for($i=$startNum;$i<($uCount-$startNum);$i++)
		{
			$weightRamps[$i]=`createNode ramp`;

				addAttr -at double -ln setU -dv ((float($i))/($uCount-1)) $weightRamps[$i];
				connectAttr ($weightRamps[$i]+".setU") ($weightRamps[$i]+".u");
				connectAttr ($weightRamps[$i]+".setU") ($weightRamps[$i]+".v");

			connectAttr ($controlRamp+".colorEntryList[0].position") ($weightRamps[$i]+".colorEntryList[0].position");
			connectAttr ($controlRamp+".colorEntryList[1].position") ($weightRamps[$i]+".colorEntryList[1].position");
			connectAttr ($controlRamp+".colorEntryList[2].position") ($weightRamps[$i]+".colorEntryList[2].position");
			connectAttr ($controlRamp+".colorEntryList[3].position") ($weightRamps[$i]+".colorEntryList[3].position");

			connectAttr ($controlRamp+".colorEntryList[0].color") ($weightRamps[$i]+".colorEntryList[0].color");
			connectAttr ($controlRamp+".colorEntryList[1].color") ($weightRamps[$i]+".colorEntryList[1].color");
			connectAttr ($controlRamp+".colorEntryList[2].color") ($weightRamps[$i]+".colorEntryList[2].color");
			connectAttr ($controlRamp+".colorEntryList[3].color") ($weightRamps[$i]+".colorEntryList[3].color");

			//interpolation & type

			connectAttr ($controlRamp+".type") ($weightRamps[$i]+".type");
			connectAttr ($controlRamp+".interpolation") ($weightRamps[$i]+".interpolation");

			for($n=0;$n<$vCount;$n++)
				connectAttr -f ($weightRamps[$i]+".outColorR") ($blendShapeNode+".inputTarget[0].inputTargetGroup[0].targetWeights["+(string($weightID++))+"]");
		}

	//create ramp controlls

		//bias & center width

	string	$reverseNode0=`createNode reverse`;

			connectAttr ($clusterTr+".uPos") ($reverseNode0+".ix");

	string	$multDoubleLinear0=`createNode multDoubleLinear`;

			setAttr ($multDoubleLinear0+".i1") -1;

			connectAttr ($clusterTr+".uPos") ($multDoubleLinear0+".i2");

	string	$multDoubleLinearNode1=`createNode multDoubleLinear`;

			connectAttr ($multDoubleLinear0+".o") ($multDoubleLinearNode1+".i1");

			connectAttr ($clusterTr+".centerWidth") ($multDoubleLinearNode1+".i2");

	string	$addDoubleLinearNode1=`createNode addDoubleLinear`;

			connectAttr ($clusterTr+".uPos") ($addDoubleLinearNode1+".i1");
			connectAttr ($multDoubleLinearNode1+".o") ($addDoubleLinearNode1+".i2");

			connectAttr ($addDoubleLinearNode1+".o") ($controlRamp+".colorEntryList[1].position");

	string	$multDoubleLinearNode2=`createNode multDoubleLinear`;

			connectAttr ($reverseNode0+".ox") ($multDoubleLinearNode2+".i1");

			connectAttr ($clusterTr+".centerWidth") ($multDoubleLinearNode2+".i2");

	string	$addDoubleLinearNode2=`createNode addDoubleLinear`;

			connectAttr ($clusterTr+".uPos") ($addDoubleLinearNode2+".i1");
			connectAttr ($multDoubleLinearNode2+".o") ($addDoubleLinearNode2+".i2");

			connectAttr ($addDoubleLinearNode2+".o") ($controlRamp+".colorEntryList[2].position");

		//falloff

	string	$reverseNode1=`createNode reverse`;

			connectAttr ($clusterTr+".fallOff") ($reverseNode1+".ix");

	string	$multDoubleLinear3=`createNode multDoubleLinear`;

			connectAttr  ($addDoubleLinearNode2+".o") ($multDoubleLinear3+".i1");
			connectAttr ($reverseNode1+".ox") ($multDoubleLinear3+".i2");

	string	$reverseNode2=`createNode reverse`;

			connectAttr ($reverseNode1+".ox") ($reverseNode2+".ix");

	string	$addDoubleLinearNode3=`createNode addDoubleLinear`;

			connectAttr ($multDoubleLinear3+".o") ($addDoubleLinearNode3+".i1");
			connectAttr ($reverseNode2+".ox") ($addDoubleLinearNode3+".i2");
			connectAttr ($addDoubleLinearNode3+".o") ($controlRamp+".colorEntryList[3].position");

	string	$multDoubleLinear4=`createNode multDoubleLinear`;

			connectAttr  ($addDoubleLinearNode1+".o") ($multDoubleLinear4+".i1");
			connectAttr ($reverseNode1+".ox") ($multDoubleLinear4+".i2");
			connectAttr ($multDoubleLinear4+".o") ($controlRamp+".colorEntryList[0].position");

		if(`objExists $inSurface`) setAttr ($computeSurface+".intermediateObject") true;

	return	{$clusterTr,$clusterSpaceGroup};
}

global proc string[] rigZenMuscle
(
	string	$sel[],
	int	$axis,
	int	$createJiggle,
	int	$spans
)
{
	int	$err;

	string	$returnVal[];

	string	$command=
		(
			"zenMuscle "+
			zenReturnStringArrayFormat($sel)+" "+
			string($axis)+" "+
			string($createJiggle)+" "+
			string($spans)
		);

		$err=catch($returnVal=eval($command));

		if($err)
		{
			progressWindow -ep;
			zenDeferCommand("undoInfo -swf 1");
		}

	return	$returnVal;
}
global proc string[] zenMuscle
(
	string	$sel[],
	int	$axis,
	int	$createJiggle,
	int	$spans
)
{
		if($spans<3) $spans=3;

	int	$local=false;//expirimental
	float	$tol=.05;

	int	$degree=2;
	int	$sectionSpans=2;

	string	$tempString;
	string	$tempStringArray[];

	/*
		for($i=0;$i<size($sel);$i++)
		{
			$sel[$i]=strip($sel[$i]);
			$sel[$i]=`substituteAllString ($sel[$i]) " " ","`;
			$sel[$i]=`substituteAllString ($sel[$i]) ",," ","`;
		}
	*/

		$sel=`stringArrayRemove {""} $sel`;

	string	$edgeLists[];
	string	$joints[];
	string	$allEdges[];
	string	$currentEdgeLists[];
	string	$previousEdgeLists[];
	string	$currentVerts[];
	string	$previousVerts[];
	string	$intersectedVerts[];

	string	$currentJointList;

	int	$z;

	//get a list of all the edges

	string	$tempStringArray[];

		for($i=0;$i<size($sel);$i++)
		{
			$tempStringArray=stringToStringArray
			(
				( strip($sel[$i]) ),","
			);

			$allEdges=stringArrayCatenate
			(
				$allEdges,
				ls
				(
					"-fl",
					(
						polyListComponentConversion
						(
							"-fe",
							"-te",
							$tempStringArray
						)
					)
				)
			);
		}

	//find out if all edges are on the same mesh

	string	$objects[]=stringArrayRemoveDuplicates(`ls -o $allEdges`);

	string	$sgMesh[];
	string	$sgEdges[];
	string	$sgCurves[];

	int	$multipleMeshes=false;

		if(size($objects)>1) $multipleMeshes=true;

	int	$firstMeshVertCount=zenReturnFirstIntegerItem(`polyEvaluate -v ($objects[0])`);

	//separate edges and joints and create ordered joint and edge lists

	string	$intersector=`stringArrayIntersector`;

	string	$allJoints[];

	string	$currentJointArray[];

	vector	$bbCenters[];
	vector	$bbCenter;
	int	$sgID[];

		for($i=0;$i<size($sel);$i++)
		{
			$tempStringArray=`stringToStringArray ($sel[$i]) ","`;
			$edges=ls("-fl",`polyListComponentConversion -fe -te $tempStringArray`);

			$currentVerts=`polyListComponentConversion -fe -tv $edges`;

			//order the edge loop rings in this selection

			$currentEdgeLists=zenOrderLoopRings(`zenIsolateLoops $edges`);

			for($n=0;$n<size($currentEdgeLists);$n++) $sgID[size($sgID)]=$i;

			$sgMesh[$i]=zenReturnFirstStringItem(`ls -o $edges`);

			if(size(stringArrayRemoveDuplicates(`ls -o $edges`))>1)
				error -sl 1 "Currently zenTools does not support muscle selection groups spanning multiple meshes.";

			//create the necessary number of joint selections to match

			$currentJointArray=`ls -type "transform" $tempStringArray`;

			$currentJointList=stringArrayToString($currentJointArray,",");

			$allJoints=stringArrayCatenate($allJoints,$currentJointArray);

			for($n=0;$n<size($currentEdgeLists);$n++)
				$joints[(size($joints))]=$currentJointList;

			if($i>0)
			{
				if($multipleMeshes)
				{
					//find which of the previous edgeLoopRings is closets to the bounding box center of the current vertices
					error -sl 1 "Currently zenTools does not support muscles spanning multiple meshes";
				}
				else
				{
					//expand current vertex selection until encountering a vertex from the previous selection

					$tempStringArray=$currentVerts;

					for($n=0;$n<$firstMeshVertCount;$n++)
					{
						stringArrayIntersector -e -r $intersector;

						$tempStringArray=polyListComponentConversion
						(
							"-fe",
							"-tv",
							polyListComponentConversion
							(
								"-te",
								"-fv",
								$tempStringArray
							)
						);

						stringArrayIntersector -e -i (`ls -fl $tempStringArray`) $intersector;
						stringArrayIntersector -e -i (`ls -fl $previousVerts`) $intersector;

						$intersectedVerts=`stringArrayIntersector -q $intersector`;

						if(size($intersectedVerts)) break;
					}

					//if the found vertices are from the first edgeLoopRing, reverse the previous array

					stringArrayIntersector -e -r $intersector;

					$tempStringArray=polyListComponentConversion("-tv",`stringToStringArray ($previousEdgeLists[0]) ","`);

					stringArrayIntersector -e -i (`ls -fl $tempStringArray`) $intersector;
					stringArrayIntersector -e -i $intersectedVerts $intersector;

					if(size(`stringArrayIntersector -q $intersector`))
						$previousEdgeLists=`zenReverseStringArray $previousEdgeLists`;

					//add the previous array to the edgeLists

					$edgeLists=stringArrayCatenate($edgeLists,$previousEdgeLists);
				}
			}

			if($i<(size($sel)-1))
			{
				$previousEdgeLists=$currentEdgeLists;
				$previousVerts=$currentVerts;
			}
		}

	//find bindPose

		$allJoints=stringArrayRemoveDuplicates($allJoints);

	string	$root=zenReturnFirstStringItem(`rigZenFindRootJoints $allJoints`);//find the root joint

	string	$bindPoseNode=zenReturnFirstStringItem(`dagPose -q -bp $root`);
		if(!objExists($bindPoseNode))
			$bindPoseNode=`dagPose -s -bp $root`;

	string	$startPose=`dagPose -s $root`;
	int	$bound=1;
	int	$success;

		$success=rigZenGoToPose($bindPoseNode);
		if(!$success)
			error -sl true ("Could not achieve pose "+$bindPoseNode+".");


	//arrange the last edge list and add to edgeLists

		if($multipleMeshes)
		{
			//wip
		}
		else
		{
			$intersectedVerts={};

			//expand previous vertex selection until encountering a vertex from the current selection

			$tempStringArray=$previousVerts;

			for($n=0;$n<$firstMeshVertCount;$n++)
			{
				stringArrayIntersector -e -r $intersector;

				$tempStringArray=polyListComponentConversion
				(
					"-fe",
					"-tv",
					polyListComponentConversion
					(
						"-te",
						"-fv",
						$tempStringArray
					)
				);

				stringArrayIntersector -e -i (`ls -fl $tempStringArray`) $intersector;
				stringArrayIntersector -e -i (`ls -fl $currentVerts`) $intersector;

				$intersectedVerts=`stringArrayIntersector -q $intersector`;

				if(size($intersectedVerts)>0) break;
			}

			//if the found vertices are not from the first edgeLoopRing, reverse the current array

			stringArrayIntersector -e -r $intersector;

			$tempStringArray=polyListComponentConversion("-tv",`stringToStringArray ($currentEdgeLists[0]) ","`);

			stringArrayIntersector -e -i (`ls -fl $tempStringArray`) $intersector;
			stringArrayIntersector -e -i $intersectedVerts $intersector;

			if(!size(`stringArrayIntersector -q $intersector`))
				$currentEdgeLists=`zenReverseStringArray $currentEdgeLists`;

			//add the current array to the edgeLists

			$edgeLists=stringArrayCatenate($edgeLists,$currentEdgeLists);
		}

	float	$rebuildDegree=$degree;

	string	$curves[];
	string	$curvesTr[];

	string	$edgesOrdered[];
	string	$edges[];

	string	$loftNode=`createNode loft`;

		setAttr ($loftNode+".degree") 1;
		setAttr ($loftNode+".sectionSpans") $sectionSpans;
		setAttr ($loftNode+".uniform") 1;
		setAttr ($loftNode+".autoReverse") 0;
		setAttr ($loftNode+".caching") 1;

	string	$dupLoftNode;

		if($axis)
		{
			$dupLoftNode=`createNode loft`;

			setAttr ($dupLoftNode+".degree") 1;
			setAttr ($dupLoftNode+".sectionSpans") $sectionSpans;
			setAttr ($dupLoftNode+".uniform") 1;
			setAttr ($dupLoftNode+".autoReverse") 0;
			setAttr ($dupLoftNode+".caching") 1;
		}

	string	$parentJoints[];
	string	$parentConstraints[];

	string	$dupJoints[];
	string	$dupParentJoints[];
	string	$dupParentConstraints[];
	string	$dupCurvesTr[];
	string	$dupCurves[];

	string	$flipTr;
	float	$tempFloatArray[];

	//determine if any curves need reversal

	int	$flipped[]=`zenQueryFlippedEdgeRingPaths true $edgeLists`;

	//create surface

	string	$dupJoints[];

	string	$aliasAttributes[];
	string	$dupAliasAttributes[];

	string	$offsetCurveNodes[];
	string	$dupOffsetCurveNodes[];

	int	$size;

	float	$distance;

	float	$meshNormalX;
	float	$meshNormalY;
	float	$meshNormalZ;

	string	$closestMesh;

	string	$juniorJoint;
	string	$dupJuniorJoint;
	string	$seniorJoint;
	string	$seniorJoints[];
	string	$dupSeniorJoint;
	string	$dupSeniorJoints[];
	int	$ancestorCount;
	float	$greatestCount=0;
	float	$smallestCount=1.#INF;
	float	$smallCount=1.#INF;

	string	$clusters[];
	string	$clusterHandles[];
	string	$dupClusters[];
	string	$dupClusterHandles[];

	string	$transformGeometry;
	string	$dummyTr;
	string	$baseCurve;
	string	$tempCurveTr;
	string	$dupTempCurveTr;

	string	$reverseNode;

		for($i=0;$i<(size($joints));$i++)
		{
			$parentJoints=stringToStringArray($joints[$i],",");
			if($axis)
			{
				$dupParentJoints=`rigZenReturnOpposingTransforms $parentJoints $root $axis $tol`;
				$dupJoints[$i]=stringArrayToString($dupParentJoints,",");
			}
			$smallCount=1.#INF;
			for($n=0;$n<(size($parentJoints));$n++)
			{
				$ancestorCount=size(stringToStringArray(zenReturnFirstStringItem(`ls -l $parentJoints[$n]`),"|"));
				if($ancestorCount<$smallestCount)
				{
					$seniorJoint=$parentJoints[$n];
					if($axis) $dupSeniorJoint=$dupParentJoints[$n];
					$smallestCount=$ancestorCount;
				}
				if($ancestorCount<$smallCount)
				{
					$seniorJoints[$i]=$parentJoints[$n];
					if($axis) $dupSeniorJoints[$i]=$dupParentJoints[$n];
					$smallCount=$ancestorCount;
				}
				if($ancestorCount>$greatestCount)
				{
					$juniorJoint=$parentJoints[$n];
					if($axis) $dupJuniorJoint=$dupParentJoints[$n];
					$greatestCount=$ancestorCount;
				}
			}
		}

		for($i=0;$i<(size($edgeLists));$i++)
		{
			$edges=`stringToStringArray ($edgeLists[$i]) ","`;

			if($local)
			{
				$curvesTr[$i]=`createNode -n "muscleCurve#" -p $seniorJoint transform`;
			}
			else
			{
				$curvesTr[$i]=`createNode -n "muscleCurve#" -p $seniorJoints[$i] transform`;
			}

			$tempCurveTr=`createNode -n "muscleCurve#" transform`;

			$curves[$i]=`createNode -p $tempCurveTr -n ($curvesTr[$i]+"Shape") nurbsCurve`;
			connectAttr (`zenEdgeCurveNode $edges 1`+".outputCurve") ($curves[$i]+".create");

			if($flipped[$i])
			{
				reverseCurve -ch 1 $curves[$i];
				$edges=`zenReverseStringArray $edges`;
				$edgeLists[$i]=`stringArrayToString $edges ","`;
			}

			delete -ch $curves[$i] $tempCurveTr;

			if($axis)
			{
				$dupTempCurveTr=zenReturnFirstStringItem(`duplicate -rc $tempCurveTr`);
				$dupCurves[$i]=zenReturnFirstStringItem(`listRelatives -s -ni $dupTempCurveTr`);

				if($local)
				{
					$dupCurvesTr[$i]=`createNode -n "muscleCurve#" -p $dupSeniorJoint transform`;
					//$dupCurvesTr[$i]=`joint -rad 0 -n "muscleCurve#" $dupSeniorJoint`;
				}
				else
				{
					$dupCurvesTr[$i]=`createNode -n "muscleCurve#" -p $dupSeniorJoints[$i] transform`;
					//$dupCurvesTr[$i]=`joint -rad 0 -n "muscleCurve#" $dupSeniorJoints[$i]`;
				}

				delete -ch $dupCurves[$i] $dupTempCurveTr;

				$tempFloatArray=`xform -q -ws -rp $root`;

				xform -ws -piv $tempFloatArray[0] $tempFloatArray[1] $tempFloatArray[2] $dupTempCurveTr;

				switch($axis)
				{
					case 1:
						xform -s -1 1 1 ($dupCurves[$i]+".cv[*]");

						break;

					case 2:
						xform -s 1 -1 1 ($dupCurves[$i]+".cv[*]");
						break;

					case 3:
						xform -s 1 1 -1 ($dupCurves[$i]+".cv[*]");
						break;
				}

				zenParentShape({$dupTempCurveTr,$dupCurvesTr[$i]});

				if(!$local)
					xform -cp ($dupCurvesTr[$i]);

				if($local)
					connectAttr -f ($dupCurves[$i]+".local") ($dupLoftNode+".inputCurve["+(string($i))+"]");
				else
					connectAttr -f ($dupCurves[$i]+".worldSpace[0]") ($dupLoftNode+".inputCurve["+(string($i))+"]");
			}

			zenParentShape({$tempCurveTr,$curvesTr[$i]});

			if(!$local)
				xform -cp ($curvesTr[$i]);

			if($local)
				connectAttr -f ($curves[$i]+".local") ($loftNode+".inputCurve["+(string($i))+"]");
			else
				connectAttr -f ($curves[$i]+".worldSpace[0]") ($loftNode+".inputCurve["+(string($i))+"]");

			//parent constraints

			$parentJoints=stringToStringArray($joints[$i],",");

			for($n=0;$n<(size($parentJoints));$n++)
				$parentConstraints[$i]=zenReturnFirstStringItem(`parentConstraint -mo -weight 1 ($parentJoints[$n]) ($curvesTr[$i])`);

			setAttr ($parentConstraints[$i]+".interpType") 0;

			if($local)
			{
				python("zen.constraints.constrainShape.constrainShape('"+$curves[$i]+"')");
				//catchQuiet(`parent $curvesTr[$i] $seniorJoints[$i]`);
			}

			if($axis)
			{
				$dupParentJoints=stringToStringArray($dupJoints[$i],",");

				for($n=0;$n<(size($dupParentJoints));$n++)
					$dupParentConstraints[$i]=zenReturnFirstStringItem(`parentConstraint -mo -weight 1 ($dupParentJoints[$n]) ($dupCurvesTr[$i])`);

				setAttr ($dupParentConstraints[$i]+".interpType") 0;

				if($local)
				{
					python("zen.constraints.constrainShape.constrainShape('"+$dupCurves[$i]+"')");
					//catchQuiet(`parent $dupCurves[$i] $dupSeniorJoints[$i]`);
				}

				$aliasAttributes=`parentConstraint -q -wal $parentConstraints[$i]`;
				$dupAliasAttributes=`parentConstraint -q -wal $dupParentConstraints[$i]`;
				if(size($aliasAttributes)>size($dupAliasAttributes))
					$size=size($dupAliasAttributes);
				else
					$size=size($aliasAttributes);
				for($n=0;$n<$size;$n++)
					connectAttr -f ($parentConstraints[$i]+"."+$aliasAttributes[$n]) ($dupParentConstraints[$i]+"."+$dupAliasAttributes[$n]);

				connectAttr -f ($parentConstraints[$i]+".interpType") ($dupParentConstraints[$i]+".interpType");
			}
		}


	//create surface

	string	$tempSurfaceTr=`createNode -n "muscle#" transform`;
	string	$surfaceTr;
		if($local)
		{
			$surfaceTr=`createNode -n "muscle#" -p $seniorJoint transform`;
		}
		else
		{
			$surfaceTr=`createNode -n "muscle#" -p $seniorJoint transform`;
		}

	string	$surfaceNode=`createNode -n ($surfaceTr+"Shape") -p ($tempSurfaceTr) nurbsSurface`;

		zenParentShape({$tempSurfaceTr,$surfaceTr});

		rigZenMakeNodesNonKeyable {$surfaceTr};

		connectAttr -f ($loftNode+".outputSurface") ($surfaceNode+".create");
		setAttr ($surfaceTr+".inheritsTransform") $local;

	//rebuild for 0-1 range

	string	$rebuildNode=`createNode rebuildSurface`;

	int	$spansU=`getAttr ($surfaceNode+".spansU")`;
	int	$spansV=`getAttr ($surfaceNode+".spansV")`;

		connectAttr -f ($loftNode+".outputSurface") ($rebuildNode+".inputSurface");

		setAttr ($rebuildNode+".keepControlPoints") 1;
		setAttr ($rebuildNode+".endKnots") 0;

		if($spansU<$degree+1)
			setAttr ($rebuildNode+".degreeU") ($spansU-1);
		else
			setAttr ($rebuildNode+".degreeU") $degree;

		if($spansV<$degree+1)
			setAttr ($rebuildNode+".degreeV") ($spansV-1);
		else
			setAttr ($rebuildNode+".degreeV") $degree;

		setAttr ($rebuildNode+".keepRange") 0;
		setAttr ($rebuildNode+".direction") 0;
		setAttr ($rebuildNode+".rebuildType") 0;
		setAttr ($rebuildNode+".endKnots") 1;

	//find out how many samples the rebuilt surface will need

	string	$firstVerts[];
	string	$lastVerts[];

	float	$closestDist=1.#INF;
	vector	$closestPoint;
	vector	$point;
	float	$pointLoc[];
	string	$closestPointOnMeshNode=`createNode closestPointOnMesh`;

		/*
		if($multipleMeshes)
		{
		}
		else
		{
			//expand the first set of edges until reaching the last set and set $rebuildNum to twice this
			$firstVerts=ls("-fl",(polyListComponentConversion("-tv",`stringToStringArray ($edgeLists[0]) ","`)));
			$lastVerts=ls("-fl",(polyListComponentConversion("-tv",`stringToStringArray ($edgeLists[(size($edgeLists)-1)]) ","`)));

			$tempStringArray=$firstVerts;

			for($i=0;$i<$firstMeshVertCount;$i++)
			{
				stringArrayIntersector -e -r $intersector;

				$tempStringArray=polyListComponentConversion
				(
					"-fe",
					"-tv",
					polyListComponentConversion
					(
						"-te",
						"-fv",
						$tempStringArray
					)
				);

				stringArrayIntersector -e -i `ls -fl $tempStringArray` $intersector;
				stringArrayIntersector -e -i $lastVerts $intersector;

				$intersectedVerts=`stringArrayIntersector -q $intersector`;

				if(size($intersectedVerts)) break;
			}

			$rebuildNum=int(float($i)*$resMult);
		}

		if($rebuildNum>$maxRes) $rebuildNum=$maxRes;
		deleteUI $intersector;
		*/



	//rebuild evenly
	string	$rebuildNode2;

		$rebuildNode2=`zenUniformSurfaceRebuild ($rebuildNode+".outputSurface") $spans -1`;
			setAttr ($rebuildNode2+".degreeU") 2;
			setAttr ($rebuildNode2+".caching") 1;
			connectAttr -f ($rebuildNode2+".outputSurface") ($surfaceNode+".create");

	//create mirror surface
	string	$dupSurfaceTr;
	string	$dupSurfaceNode;
	string	$dupRebuildNode;
	string	$dupRebuildNode2;
	string	$dupReverseSurfaceNode;
	string	$dupTempSurfaceTr;

		if($axis)
		{
			$dupTempSurfaceTr=`createNode -n "muscle#" transform`;
			if($local)
			{
				$dupSurfaceTr=`createNode -n "muscle#" -p $dupSeniorJoint transform`;
			}
			else
			{
				$dupSurfaceTr=`createNode -n "muscle#" -p $dupSeniorJoint transform`;
			}

			$dupSurfaceNode=`createNode -n ($dupSurfaceTr+"Shape") -p ($dupTempSurfaceTr) nurbsSurface`;

			zenParentShape({$dupTempSurfaceTr,$dupSurfaceTr});

			rigZenMakeNodesNonKeyable {$dupSurfaceTr};

				connectAttr -f ($dupLoftNode+".outputSurface") ($dupSurfaceNode+".create");

				setAttr ($dupSurfaceTr+".inheritsTransform") $local;

			//rebuild for 0-1 range

			$dupRebuildNode=`createNode rebuildSurface`;

				connectAttr -f ($dupLoftNode+".outputSurface") ($dupRebuildNode+".inputSurface");
				connectAttr -f ($dupRebuildNode+".outputSurface") ($dupSurfaceNode+".create");

				setAttr ($dupRebuildNode+".keepControlPoints") 1;
				setAttr ($dupRebuildNode+".endKnots") 0;

				if($spansU<$degree+1)
					setAttr ($dupRebuildNode+".degreeU") ($spansU-1);
				else
					setAttr ($dupRebuildNode+".degreeU") $degree;

				if($spansV<$degree+1)
					setAttr ($dupRebuildNode+".degreeV") ($spansV-1);
				else
					setAttr ($dupRebuildNode+".degreeV") $degree;

				setAttr ($dupRebuildNode+".keepRange") 0;
				setAttr ($dupRebuildNode+".direction") 0;
				setAttr ($dupRebuildNode+".rebuildType") 0;
				setAttr ($dupRebuildNode+".endKnots") 1;

			$dupRebuildNode2=`zenUniformSurfaceRebuild ($dupRebuildNode+".outputSurface") $spans -1`;

				setAttr ($dupRebuildNode2+".degreeU") 2;

				connectAttr -f ($dupRebuildNode2+".outputSurface") ($dupSurfaceNode+".create");

			$dupReverseSurfaceNode=`createNode reverseSurface`;

				setAttr ($dupReverseSurfaceNode+".direction") 1;

				connectAttr -f ($dupLoftNode+".outputSurface") ($dupReverseSurfaceNode+".inputSurface");
				connectAttr -f ($dupReverseSurfaceNode+".outputSurface") ($dupRebuildNode+".inputSurface");

				setAttr ($dupReverseSurfaceNode+".nodeState") 1;
		}

	//set display

		setAttr ($surfaceNode+".overrideEnabled") 1;
		setAttr ($surfaceNode+".overrideShading") 0;
		setAttr ($surfaceNode+".overrideColor") 13;

		setAttr ($surfaceNode+".curvePrecisionShaded") 4;

		if($axis)
		{
			setAttr ($dupSurfaceNode+".overrideEnabled") 1;
			setAttr ($dupSurfaceNode+".overrideShading") 0;
			setAttr ($dupSurfaceNode+".overrideColor") 13;

			setAttr ($dupSurfaceNode+".curvePrecisionShaded") 4;
		}

	//determine if surface needs to be flipped

		$closestDist=1.#INF;

	string	$reverseSurfaceNode=`createNode reverseSurface`;
			setAttr ($reverseSurfaceNode+".direction") 1;
			connectAttr -f ($loftNode+".outputSurface") ($reverseSurfaceNode+".inputSurface");
			connectAttr -f ($reverseSurfaceNode+".outputSurface") ($rebuildNode+".inputSurface");
			setAttr ($reverseSurfaceNode+".nodeState") 1;

	string	$pointOnSurfaceInfoNode=`createNode pointOnSurfaceInfo`;

		connectAttr ($rebuildNode+".outputSurface") ($pointOnSurfaceInfoNode+".inputSurface");

		setAttr ($pointOnSurfaceInfoNode+".parameterU") .5;
		setAttr ($pointOnSurfaceInfoNode+".parameterV") .5;

		for($o in $objects)
		{
			if(!`isConnected ($o+".worldMesh[0]") ($closestPointOnMeshNode+".inMesh")`)
				connectAttr ($o+".worldMesh[0]") ($closestPointOnMeshNode+".inMesh");

			$pointLoc=`getAttr ($pointOnSurfaceInfoNode+".position")`;

			setAttr ($closestPointOnMeshNode+".inPosition") $pointLoc[0] $pointLoc[1] $pointLoc[2];

			$point=vector(<<(float(`getAttr ($closestPointOnMeshNode+".px")`)),(float(`getAttr ($closestPointOnMeshNode+".py")`)),(float(`getAttr ($closestPointOnMeshNode+".pz")`))>>);

			$distance=mag(<<($pointLoc[0]),($pointLoc[1]),($pointLoc[2])>>-$point);

			if($distance<$closestDist)
			{
				$closestDist=$distance;
				$closestMesh=$o;
				$closestPoint=$point;
			}
		}

		if(!`isConnected ($closestMesh+".worldMesh[0]") ($closestPointOnMeshNode+".inMesh")`)
			connectAttr -f ($closestMesh+".worldMesh[0]") ($closestPointOnMeshNode+".inMesh");

		setAttr ($closestPointOnMeshNode+".inPosition") ($closestPoint.x) ($closestPoint.y) ($closestPoint.z);

		$meshNormalX=`getAttr ($closestPointOnMeshNode+".normalX")`;
		$meshNormalY=`getAttr ($closestPointOnMeshNode+".normalY")`;
		$meshNormalZ=`getAttr ($closestPointOnMeshNode+".normalZ")`;

	float	$surfaceNormalX=`getAttr ($pointOnSurfaceInfoNode+".normalX")`;
	float	$surfaceNormalY=`getAttr ($pointOnSurfaceInfoNode+".normalY")`;
	float	$surfaceNormalZ=`getAttr ($pointOnSurfaceInfoNode+".normalZ")`;

	float	$normalDifference=mag(<<$surfaceNormalX,$surfaceNormalY,$surfaceNormalZ>>-<<$meshNormalX,$meshNormalY,$meshNormalZ>>);

		if($normalDifference>1)
		{
			setAttr ($reverseSurfaceNode+".nodeState") 0;
		}
		else
		{
			if($axis)
				setAttr ($dupReverseSurfaceNode+".nodeState") 0;
		}

		delete $pointOnSurfaceInfoNode $closestPointOnMeshNode;

	//offset

	string	$offsetSurfaceNode=`createNode offsetSurface`;
			setAttr ($offsetSurfaceNode+".distance") 0;
			connectAttr -f ($rebuildNode2+".outputSurface") ($offsetSurfaceNode+".inputSurface");
			connectAttr -f ($offsetSurfaceNode+".outputSurface") ($surfaceNode+".create");

	string	$offsetSurfaceBase=`createNode offsetSurface`;
			setAttr ($offsetSurfaceBase+".distance") 0;

	string	$dupOffsetSurfaceNode;
	string	$dupOffsetSurfaceBase;

		if($axis)
		{
			$dupOffsetSurfaceNode=`createNode offsetSurface`;
				setAttr ($dupOffsetSurfaceNode+".distance") 0;
				connectAttr -f ($dupRebuildNode2+".outputSurface") ($dupOffsetSurfaceNode+".inputSurface");
				connectAttr -f ($dupOffsetSurfaceNode+".outputSurface") ($dupSurfaceNode+".create");

			$dupOffsetSurfaceBase=`createNode offsetSurface`;
				setAttr ($dupOffsetSurfaceBase+".distance") 0;
		}

	//create handles
		$tempStringArray=`rigZenTangentSpaceMuscleCluster $surfaceNode $createJiggle 0`;
	string	$handle=$tempStringArray[0];
	string	$handleGroup=$tempStringArray[1];

			addAttr -k true -ln "offset" -at double $handle;
			connectAttr -f ($handle+".offset") ($offsetSurfaceNode+".distance");
			connectAttr -f ($handle+".offset") ($offsetSurfaceBase+".distance");


		dagPose -name $bindPoseNode -a $handle;

	int	$nextPlug;
	string	$sgEdgeList[];
	int	$sgEdgeID;

		addAttr -nc 2 -ln "zenMuscleInputs" -sn "zmi" -at compound -m $handle ;
			addAttr -ln "zenMuscleInputMesh" -sn "zmim" -p "zenMuscleInputs" -at message $handle ;
			addAttr -nc 2 -ln "zenMuscleInputCurves" -sn "zmics" -p "zenMuscleInputs" -at compound -m $handle ;
				addAttr -ln "zenMuscleInputCurve" -sn "zmic" -p "zenMuscleInputCurves" -at message $handle;
				addAttr -ln "zenMuscleInputEdges" -sn "zmie" -p "zenMuscleInputCurves" -at long -m $handle;

		for($i=0;$i<size($sgMesh);$i++)
		{
			connectAttr ($sgMesh[$i]+".message") ($handle+".zenMuscleInputs["+(string($i))+"].zenMuscleInputMesh");
		}

		for($i=0;$i<size($curvesTr);$i++)
		{
			$nextPlug=zenFirstOpenPlug($handle+".zenMuscleInputs["+(string($sgID[$i]))+"].zmics");
			connectAttr ($curvesTr[$i]+".message") ($handle+".zmi["+(string($sgID[$i]))+"].zmics["+(string($nextPlug))+"].zmic");

			$sgEdgeList=stringToStringArray($edgeLists[$i],",");
			for($n=0;$n<size($sgEdgeList);$n++)
			{
				$sgEdgeID=zenCompID($sgEdgeList[$n]);
				setAttr ($handle+".zmi["+(string($sgID[$i]))+"].zmics["+(string($nextPlug))+"].zmie["+(string($n))+"]") $sgEdgeID;
			}
		}

	string	$dupHandle;
	string	$dupHandleSpaces[];
	string	$sharedAttributes[];
	string	$dupHandleGroup;

		if($axis)
		{
			$tempStringArray=`rigZenTangentSpaceMuscleCluster $dupSurfaceNode $createJiggle 1`;
			$dupHandle=$tempStringArray[0];
			$dupHandleGroup=$tempStringArray[1];

				addAttr -k true -ln "offset" -at double $dupHandle;
				connectAttr -f ($dupHandle+".offset") ($dupOffsetSurfaceNode+".distance");
				connectAttr -f ($dupHandle+".offset") ($dupOffsetSurfaceBase+".distance");
				connectAttr ($handle+".message") ($dupHandle+".zenOpposite");
				connectAttr ($dupHandle+".message") ($handle+".zenOpposite");

			dagPose -name $bindPoseNode -a $dupHandle;

			addAttr -nc 2 -ln "zenMuscleInputs" -sn "zmi" -at compound -m $dupHandle ;
				addAttr -ln "zenMuscleInputMesh" -sn "zmip" -p "zenMuscleInputs" -at message $dupHandle ;
				addAttr -nc 2 -ln "zenMuscleInputCurves" -sn "zmics" -p "zenMuscleInputs" -at compound -m $dupHandle ;
					addAttr -ln "zenMuscleInputCurve" -sn "zmic" -p "zenMuscleInputCurves" -at message $dupHandle;
					addAttr -ln "zenMuscleInputEdges" -sn "zmie" -p "zenMuscleInputCurves" -at long -m $dupHandle ;

			connectAttr ($handle+".zenMuscleInputs") ($dupHandle+".zenMuscleInputs");

			$tempStringArray=zenReturnTopLevelTransforms(`ls -l $dupHandle`);

			$dupHandleSpaces=`listRelatives -c $tempStringArray`;

			//setAttr ($dupHandle+".handleOffsetX") (getAttr($dupHandle+".handleOffsetX"));

			for($d in $dupHandleSpaces)
			{
				setAttr -lock false ($d+".sz");
				setAttr -lock true ($d+".sz") -1;
			}

			//connect shared attributes

			$sharedAttributes=
			{
				"uPos",
				"fallOff",
				"centerWidth",
				"tangentSpace",
				"handleOffsetX",
				"handleOffsetY",
				"handleOffsetZ",
				"handleRadius",
				"offset"
			};

			if($createJiggle)
			{
				$sharedAttributes=stringArrayCatenate
				(
					$sharedAttributes,
					{
						"jiggle",
						"jEnvelope",
						"jDamping",
						"jStiffness",
						"jWeight",
						"jForceNormal",
						"jForceTangent",
						"jDirBias",
						"jIgnoreTr",
						"jMotionMult"
					}
				);
			}

			for($s in $sharedAttributes)
				if( objExists($handle+"."+$s) && objExists($dupHandle+"."+$s) )
					connectAttr -f ($handle+"."+$s) ($dupHandle+"."+$s);
		}

	//skinning

	string	$skinClusters[]=stringArrayRemoveDuplicates(ls("-type","skinCluster",`listHistory $objects`));

		if(`pluginInfo -q -l MayaMuscle`)
			$skinClusters=stringArrayCatenate($skinClusters,stringArrayRemoveDuplicates(ls("-type","cMuscleSystem",`listHistory $objects`)));

	string	$baseShape;
	string	$cMuscleObject;
	string	$dupCMuscleObject;

	int	$nextBindPosePlug;

	int	$plug;

	float	$maxBindDistance;
	int 	$musIdxs[];
	int 	$test;
	int 	$done;
	int	$parentBindPosePlug;
	int	$dupParentBindPosePlug;
	string	$offsetBaseShape;
	string	$dupOffsetBaseShape;
	string	$dupBaseShape;
	string	$closeSurface;
	string	$dupCloseSurface;
	string	$closeBase;
	string	$dupCloseBase;
	string	$baseTr;
	string	$dupBaseTr;
	string	$baseOffsetTr;
	string	$dupBaseOffsetTr;

		xform -cp $surfaceTr;//center pivot

		if(size($skinClusters) || (`pluginInfo -q -l MayaMuscle` && size(ls("-type","cMuscleSystem",$skinClusters))))
		{
			$baseTr=zenReturnFirstStringItem(`duplicate -rc $surfaceTr`);
			$baseShape=zenReturnFirstStringItem(listRelatives("-s","-ni",$baseTr));
			$baseOffsetTr=zenReturnFirstStringItem(`duplicate -rc $surfaceTr`);
			$offsetBaseShape=zenReturnFirstStringItem(listRelatives("-s","-ni",$baseOffsetTr));
			$baseShape=`rename $baseShape ($surfaceTr+"Base#")`;
			$offsetBaseShape=`rename $offsetBaseShape ($surfaceTr+"Base#")`;

			//because the base is a world space shape that is actually in object space but acting locally
			//and we can't just disconnect the attribute an leave a cached mesh attribute because we are using history to
			//adjust the "offset" after binding
			if($local)
			{
				parent -w $baseTr;
				parent -w $baseOffsetTr;
				parent -r $baseTr $seniorJoint;
				parent -r $baseOffsetTr $seniorJoint;
			}

			zenParentShape {$baseTr,$surfaceTr};
			zenParentShape {$baseOffsetTr,$surfaceTr};

			connectAttr -f ($baseShape+".local") ($offsetSurfaceBase+".inputSurface");
			connectAttr -f ($offsetSurfaceBase+".outputSurface") ($offsetBaseShape+".create");
			setAttr ($baseShape+".intermediateObject") 1;
			setAttr ($offsetBaseShape+".intermediateObject") 1;

			if($axis)
			{
				$dupBaseTr=zenReturnFirstStringItem(`duplicate -rc $dupSurfaceTr`);
				$dupBaseShape=zenReturnFirstStringItem(listRelatives("-s","-ni", $dupBaseTr));
				$dupBaseOffsetTr=zenReturnFirstStringItem(`duplicate -rc $dupSurfaceTr`);
				$dupOffsetBaseShape=zenReturnFirstStringItem(listRelatives("-s","-ni",$dupBaseOffsetTr));
				$dupBaseShape=`rename $dupBaseShape ($dupSurfaceTr+"Base#")`;
				$dupOffsetBaseShape=`rename $dupOffsetBaseShape ($dupSurfaceTr+"Base#")`;

				if($local)
				{
					parent -w $dupBaseTr;
					parent -w $dupBaseOffsetTr;
					parent -r $dupBaseTr $dupSeniorJoint;
					parent -r $dupBaseOffsetTr $dupSeniorJoint;
				}

				zenParentShape {$dupBaseTr,$dupSurfaceTr};
				zenParentShape {$dupBaseOffsetTr,$dupSurfaceTr};

				connectAttr -f ($dupBaseShape+".local") ($dupOffsetSurfaceBase+".inputSurface");
				connectAttr -f ($dupOffsetSurfaceBase+".outputSurface") ($dupOffsetBaseShape+".create");
				setAttr ($dupBaseShape+".intermediateObject") 1;
				setAttr ($dupOffsetBaseShape+".intermediateObject") 1;
			}
		}



	//create muscle object if there are muscle systems present
		if(`pluginInfo -q -l MayaMuscle` && size(ls("-type","cMuscleSystem",$skinClusters)))
		{
			$cMuscleObject=`createNode "cMuscleObject" -name ($surfaceTr+"Shape#") -p $surfaceTr` ;
				connectAttr -f ($surfaceNode+".worldSpace") ($cMuscleObject+".meshIn");

				if($local)
					connectAttr -f ($offsetBaseShape+".local") ($cMuscleObject+".meshInBase");
				else
					connectAttr -f ($offsetBaseShape+".worldSpace") ($cMuscleObject+".meshInBase");

				connectAttr -f ($surfaceTr+".worldMatrix") ($cMuscleObject+".worldMatrixStart") ;
				setAttr ($cMuscleObject+".type") 1;
				setAttr ($cMuscleObject+".draw") 0;
				setAttr -keyable 0 ($cMuscleObject+".length");
				setAttr -keyable 0 ($cMuscleObject+".radius") ;
				setAttr -keyable 0 ($cMuscleObject+".capsuleAxis");
				setAttr -keyable 0 ($cMuscleObject+".nSeg");
				setAttr -keyable 0 ($cMuscleObject+".nSides");

			$maxBindDistance=(`arclen -ch 0 ($surfaceNode+".v[.5]")`)/2;

			if($axis)
			{
				$dupCMuscleObject=`createNode "cMuscleObject" -name ($dupSurfaceTr+"Shape#") -p $dupSurfaceTr`;
					connectAttr -f ($dupSurfaceNode+".worldSpace") ($dupCMuscleObject+".meshIn");

					if($local)
						connectAttr -f ($dupOffsetBaseShape+".local") ($dupCMuscleObject+".meshInBase");
					else
						connectAttr -f ($dupOffsetBaseShape+".worldSpace") ($dupCMuscleObject+".meshInBase");

					connectAttr -f ($dupSurfaceTr+".worldMatrix") ($dupCMuscleObject+".worldMatrixStart") ;
					setAttr ($dupCMuscleObject+".type") 1;
					setAttr ($dupCMuscleObject+".draw") 0;
					setAttr -keyable 0 ($dupCMuscleObject+".length");
					setAttr -keyable 0 ($dupCMuscleObject+".radius") ;
					setAttr -keyable 0 ($dupCMuscleObject+".capsuleAxis");
					setAttr -keyable 0 ($dupCMuscleObject+".nSeg");
					setAttr -keyable 0 ($dupCMuscleObject+".nSides");
			}
		}

		if(size($skinClusters))
		{
			//connectAttr -f ($rebuildBase2+".outputSurface") ($baseShape+".create");
			//setAttr ($handle+".offset") (-$closestDist*1.5);

			addAttr -at short -ln "dropoff" $surfaceTr;
				setAttr -k 0 -cb true ($surfaceTr+".dropoff") 4;

			addAttr -at short -ln "samples" $surfaceTr;
				setAttr -k 0 -cb true ($surfaceTr+".samples") 10;

			for($s in $skinClusters)
			{
				if(nodeType($s)=="skinCluster")
					$plug=`zenNextPlug ($s+".matrix")`;
				else
				if(nodeType($s)=="cMuscleSystem")
				{
					$musIdxs= sort(`cMuscleQuery -system $s -muscle -index`);
					$plug=0;
					$done=0 ;
					for ($test=0;$test<size($musIdxs); ++$test)
					{
						if ($test != $musIdxs[$test])
						{
							$plug=$test;
							$done=1;
							break;
						}
						++$plug;
					}
				}

				$nextBindPosePlug=`zenNextPlug ($bindPoseNode+".members")`;

				if(nodeType($s)=="skinCluster")
				{
					skinCluster -e -ug -ns 10 -wt 0 -ai $surfaceTr -bsh $offsetBaseShape $s;
						connectAttr -f ($surfaceTr+".dropoff") ($s+".dropoff["+(string($plug))+"]");
						connectAttr -f ($surfaceTr+".samples") ($s+".nurbsSamples["+(string($plug))+"]");
				}
				else
				if(nodeType($s)=="cMuscleSystem")
				{
					setAttr ($s+".envelope") 0;
					connectAttr -f ($cMuscleObject+".muscleData") ($s+".muscleData["+$plug+"]") ;
					cMuscleBindSticky -system $s -muscle $cMuscleObject -d $maxBindDistance;
				}

				if(nodeType($s)=="cMuscleSystem")
				{
					zenDeferCommand
					(
						"setAttr \""+$s+".envelope\" 1"
					);
				}

			}

			setAttr ($surfaceTr+".visibility") 1;

			if($axis)
			{
				addAttr -at short -ln "dropoff" $dupSurfaceTr;

					setAttr -k 0 -cb true ($dupSurfaceTr+".dropoff") 4;

				addAttr -at short -ln "samples" $dupSurfaceTr;

					setAttr -k 0 -cb true ($dupSurfaceTr+".samples") 10;

				for($s in $skinClusters)
				{
					if(nodeType($s)=="skinCluster")
						$plug=`zenNextPlug ($s+".matrix")`;
					else
					if(nodeType($s)=="cMuscleSystem")
					{
						$musIdxs= sort(`cMuscleQuery -system $s -muscle -index`);
						$plug=0;
						$done=0 ;
						for ($test=0;$test<size($musIdxs); ++$test)
						{
							if ($test != $musIdxs[$test])
							{
								$plug=$test;
								$done=1;
								break;
							}
							++$plug;
						}
					}

					$nextBindPosePlug=`zenNextPlug ($bindPoseNode+".members")`;

					if(nodeType($s)=="skinCluster")
					{
						skinCluster -e -ug -ns 10 -wt 0 -ai $dupSurfaceTr -bsh $dupOffsetBaseShape $s;
						connectAttr -f ($dupSurfaceTr+".dropoff") ($s+".dropoff["+(string($plug))+"]");
						connectAttr -f ($dupSurfaceTr+".samples") ($s+".nurbsSamples["+(string($plug))+"]");
					}
					else
					if(nodeType($s)=="cMuscleSystem")
					{
						setAttr ($s+".envelope") 0;
						connectAttr -f ($dupCMuscleObject+".muscleData") ($s+".muscleData["+$plug+"]") ;
						cMuscleBindSticky -system $s -muscle $dupCMuscleObject -d $maxBindDistance;
					}

					if(nodeType($s)=="cMuscleSystem")
					{
						zenDeferCommand
						(
							"setAttr \""+$s+".envelope\" 1"
						);
					}
				}

				setAttr ($dupSurfaceTr+".visibility") 1;
			}
		}
		else
		{
			setAttr ($baseShape+".intermediateObject") 1;
			setAttr ($offsetBaseShape+".intermediateObject") 1;
			if($axis)
			{
				setAttr ($dupBaseShape+".intermediateObject") 1;
				setAttr ($dupOffsetBaseShape+".intermediateObject") 1;
			}
		}

	int	$done=0;

		if(objExists($startPose))
		{
			$success=rigZenGoToPose($startPose);
			if(!$success) error -sl true "Could not achieve pose.";
			delete $startPose;
		}

		for($c in $curvesTr)
			dagPose -name $bindPoseNode -remove $c;
		for($c in $dupCurvesTr)
			dagPose -name $bindPoseNode -remove $c;
		dagPose -name $bindPoseNode -remove $surfaceTr;
		if($axis) dagPose -name $bindPoseNode -remove $dupSurfaceTr;

		/*
	string	$decomposeMatrix;
	string	$dupDecomposeMatrix;

		$decomposeMatrix=`createNode decomposeMatrix`;
		connectAttr -f ($seniorJoint+".worldInverseMatrix[0]") ($decomposeMatrix+".inputMatrix");
		connectAttr -f ($decomposeMatrix+".os") ($surfaceTr+".s");
		if($axis)
		{
			$dupDecomposeMatrix=`createNode decomposeMatrix`;
			connectAttr -f ($dupSeniorJoint+".worldInverseMatrix[0]") ($dupDecomposeMatrix+".inputMatrix");
			connectAttr -f ($dupDecomposeMatrix+".os") ($dupSurfaceTr+".s");
		}
		*/

		rigZenLockTransforms({$surfaceTr});
		rigZenMakeNodesNonKeyable($parentConstraints);
		rigZenMakeNodesNonKeyable($curvesTr);
		if($axis)
		{
			rigZenLockTransforms({$dupSurfaceTr});
			rigZenMakeNodesNonKeyable($dupParentConstraints);
			rigZenMakeNodesNonKeyable($dupCurvesTr);
		}

		//naming
	string	$names[];

		$names[0]=$juniorJoint+"_muscle";

		if($axis)
			$names[1]=$dupJuniorJoint+"_muscle";


		$handle=`rename $handle (zenUniqueName($names[0]+"_handle"))`;
		$surfaceTr=`rename $surfaceTr (zenUniqueName($names[0]))`;
		for($i=0;$i<size($curvesTr);$i++)
			$curvesTr[$i]=`rename $curvesTr[$i] (zenUniqueName($names[0]+"_curve1"))`;
		if($axis)
		{
			$dupHandle=`rename $dupHandle (zenUniqueName($names[1]+"_handle"))`;
			$dupSurfaceTr=`rename $dupSurfaceTr (zenUniqueName($names[1]))`;
			for($i=0;$i<size($dupCurvesTr);$i++)
				$dupCurvesTr[$i]=`rename $dupCurvesTr[$i] (zenUniqueName($names[1]+"_curve1"))`;
		}

	string	$returnVal[];

		if($axis)
			$returnVal=stringArrayCatenate(stringArrayCatenate({$handle,$dupHandle,$surfaceTr,$dupSurfaceTr},$curvesTr),$dupCurvesTr);
		else
			$returnVal=stringArrayCatenate({$handle,$surfaceTr},$curvesTr);

	return	$returnVal;
}