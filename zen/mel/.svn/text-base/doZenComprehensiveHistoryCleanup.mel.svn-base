//breaks incoming and/or outgoing connections, deletes history, deletes intermediate objects
global proc string[] doZenComprehensiveHistoryCleanup()
{
	int	$destinationConnections=true;

	string 	$nodes[]=`ls -sl`;
	string	$failed;
		
	//find all the nodes
	string	$trNodes[]=`ls -type transform $nodes`;
	string	$shapeNodes[]=`listRelatives -pa -s -ni $nodes`;
	string	$intermediateObjects[]=stringArrayRemove($shapeNodes,`listRelatives -pa -s $nodes`);
	
		$shapeNodes=stringArrayCatenate($shapeNodes,`ls -type shape $nodes`);
		$shapeNodes=`stringArrayRemoveDuplicates $shapeNodes`;
		$trNodes=`stringArrayRemoveDuplicates $trNodes`;
		
	//get history
	string	$history[]=`listHistory $shapeNodes $trNodes`;
		
	//if nodes are locked, unlock
		lockNode -lock 0 $trNodes $shapeNodes;
		
	//try to delete history
		catchQuiet(`delete -ch $shapeNodes`);
		catchQuiet(`delete -ch $trNodes`);
		
	//get connections	
	string	$targetObj;
	string	$connectionsIn[]=`listConnections -c 1 -s 1 -d 0 -p 1 $shapeNodes $trNodes`;
	
	//source connections
		for($i=0;$i<size($connectionsIn)-1;$i+=2)
		{
			//if connection is not a shader, disconnect
			if
			(
				!`gmatch $connectionsIn[$i] "*.mi*Approx*"` &&
				!`gmatch $connectionsIn[$i] "*.instObjGroups*"`
			)
			{
				catchQuiet(`disconnectAttr $connectionsIn[$i+1] $connectionsIn[$i]`);
			}
		}

		$targetObj=zenReturnFirstStringItem(`stringToStringArray $connectionsIn[$i+1] "."`);
		if(`objExists $targetObj`)
		{
			if(`getAttr ($targetObj+".intermediateObject")`)
				delete $targetObj;
		}
		
	//destination connections
	string	$connectionsOut[]=`listConnections -c 1 -s 0 -d 1 -p 1 $shapeNodes $trNodes`;
	string	$returnVal[]=$connectionsOut;
	string	$exceptions[];
	int	$disconnect;		
	
		if($destinationConnections)
		{
			for($i=0;$i<size($connectionsOut)-1;$i+=2)
			{
				//if connection is not a shader, disconnect
				if
				(
					!`gmatch $connectionsOut[$i] "*.instObjGroups*"` && 
					!`gmatch $connectionsOut[$i] "*.mi*Approx*"` &&
					!`gmatch $connectionsOut[$i] "*.uvSet*"` &&
					!`gmatch $connectionsOut[$i+1] "*.drawOverride*"`
					
				)
				{
					catchQuiet(`disconnectAttr $connectionsOut[$i] $connectionsOut[$i+1]`);
				}
				
				$targetObj=zenReturnFirstStringItem(`stringToStringArray $connectionsOut[$i+1] "."`);
				if(`objExists ($targetObj+".intermediateObject")`)
				{
					if(`getAttr ($targetObj+".intermediateObject")`)
						delete $targetObj;
				}
				
				if(!`objExists $targetObj`) 
					$returnVal=`stringArrayRemove {$connectionsOut[$i],$connectionsOut[$i+1]} $returnVal`;
			}
		}
		
		if(size($intermediateObjects))
		{
			for($interObj in $intermediateObjects)
			{
				if(`objExists $interObj`)
					delete $interObj;
			}
		}
		
	//delete history nodes which now have no output connections feeding a shape node
	string	$future[];
	int	$relevant;
		if(size($history))
		{
			for($h in $history)
			{
				if(`objExists $h`)
				{
					$relevant=0;
					$future=`listHistory -f true $h`;
					
					for($f in $future)
					{
						if(size(`ls -type shape $f`) || size(`ls -type transform $f`))
						{
							if(!`getAttr ($f+".intermediateObject")`)
								$relevant=1;
						}
					}
							
					if($relevant==0)
						delete $h;
				}
			}
		}
		
		print "Cleaning finished.";
		
	return	$returnVal;
}